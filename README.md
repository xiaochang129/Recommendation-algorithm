# 十大经典排序算法
    1、冒泡  排序换位。
    2、选择  选最小换位到第一个位置。
    3、插入  前面有序，后面插入前列。
    4、希尔  缩小增量排序
    5、归并  2路归并，分治。
    6、快排  选定种子，切分。
    7、堆排  建堆。
    8、计数  找到最大值最小值计数排。
    9、桶    将数据分到有限数量的桶里，每个桶再分别排序
    10、基数 按数值的进制位数排序。
   
# 召回、粗排、精排和重排
    召回：用户部分特征，从海量的物品库里，快速找回一小部分用户潜在感兴趣的物品，召回强调快。
    粗排：通过少量用户和物品特征，简单模型，来对召回的结果进行个粗略的排序，在保证一定精准的前提下，进一步减少往后传送的物品数量，可用可不同
    精排：使用你能想到的任何特征，可以上你能承受速度极限的复杂模型，尽量精准地对物品进行个性化排序。
    重排：技术产品策略主导或者为了改进用户体验的操作比如去已读、去重、打散、多样性保证、固定类型物品插入等等。

# 协同过滤
    协同：寻找用户之间的相似性或者标的物之间的相似性
    过滤：就是从标的物中将用户喜欢的找出来。
    缺点：(1) 冷启动问题：如果用户行为少，对于新入库的标的物，由于只有很少的用户操作行为，。可以采用人工的策略将该标的物在一定的位置曝光。
          (2) 稀疏性问题:用户基数大，标的物数量多,一般用户只对很少量的标的物产生操作行为，这是用户操作行为矩阵是非常稀疏的，标的物相似度不够精准。

# 深度学习排序
     之前是用gbdt二分类，排序。
     后来用深度学习Wide&Deep，DeepFM等。这些方法一般的思路是：
                Embedding层 Embedding Vector 
                多个全联接层，MLPs
                sigmoid函数
                0-1值，代表点击的概率

     Wide&Deep
       特征： user features (e.g., country, language, demographics)；
             contextual features (e.g., device, hour of the day, day of the week)；
             impression features (e.g., app age, historical statistics of an app).
       Wide：线性系数*特征,特征的乘积
       Deep：特征embedding->concate->全连接
       logistc预测
       
     DeepFM
       采取Wide & Deep的框架，差异在于将Wide部分的LR替换为了FM
       FM：一维特征concate高维特征相乘，


# 今日头条
    使用算法：协同过滤、LR、因式分解、DNN、GBDT
    使用特征：环境：地理位置、时间。
             热度：全局热度、分类热度，主题热度，以及关键词热度等。在冷启动的时候非常有效。
             协同：在部分程度上帮助解决所谓算法越推越窄的问题，通过用户行为分析不同用户间相似性，比如点击相似、兴趣分类相似
    召回：基于内容相似性、用户相似性、项目、个人训练模型等查找并排序。今日头条使用倒排。
    
